# 0. 编译

编译的整体环境设置请参考03号文件，在此不再详述。

<span style="color:red">**区别**</span>（一定注意）: 不能执行原来的环境设置脚本 `**loongarch64.lunch**`, 而必须执行板子的配置<span style="color:blue">`lboard.lunch `</span>

```bash
$ ll *.lunch
lrwxrwxrwx 1 wendong wendong 25  6月 20 18:03 lboard.lunch -> art/xc_tools/lboard.lunch
lrwxrwxrwx 1 wendong wendong 30  6月 25 19:16 loongarch64.lunch -> art/xc_tools/loongarch64.lunch

$ cat lboard.lunch 
. build/envsetup.sh
#lunch aosp_loongarch64-eng
lunch loongson_3a5000-eng

#export ANDROID_SERIAL=emulator-5554
```



0.1 设置地址

脚本在文件 `device/generic/goldfish/init.ranchu-core.sh`  中

```
/system/bin/ifconfig eth0 up
/system/bin/ifconfig eth0 192.168.3.10
sleep 10
/system/bin/ip rule add from all lookup main pref 1
```



# 1.硬件准备

### 1.1 硬盘信息确认

这里为了方便调试采用的是双系统方案:

1. 单一硬盘：硬盘分区格式是gpt格式，其中分区1-4是loongnix系统，分区5-8分别是安卓的super,data,cache,metadata分区，<span style="color:blue">**分区9用来放置内核和ramdisk等一些启动程序**</span>。
2. 双硬盘：如果是两个独立硬盘，其信息如下（熵核目前采用的方式）【<span style="color:blue">**注意/dev/sda5-boot分区暂时没有使用** </span>】: 

```bash
# 第一步，获取硬盘信息
$ lsblk
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
sda      8:0    0 238.5G  0 disk 
├─sda1   8:1    0    16G  0 part 
├─sda2   8:2    0     8G  0 part 
├─sda3   8:3    0     2G  0 part 
├─sda4   8:4    0     1G  0 part 
└─sda5   8:5    0     1G  0 part 
sdb      8:16   0 238.5G  0 disk 
├─sdb1   8:17   0   300M  0 part /boot/efi
├─sdb2   8:18   0   300M  0 part /boot
├─sdb3   8:19   0  41.3G  0 part /
├─sdb4   8:20   0  41.3G  0 part 
├─sdb5   8:21   0 146.5G  0 part /opt
│                                /root
│                                /home
│                                /var
│                                /data
└─sdb6   8:22   0   8.8G  0 part [SWAP]


## 第二步分区，我们将sda硬盘作为Android启动硬盘，并做如下分区（一定采用gdisk工具进行分区）
$ sudo gdisk -l /dev/sda
GPT fdisk (gdisk) version 1.0.3

Partition table scan:
  MBR: protective
  BSD: not present
  APM: not present
  GPT: present

Found valid GPT with protective MBR; using GPT.
Disk /dev/sda: 500118192 sectors, 238.5 GiB
Model: GG46T256S3C27   
Sector size (logical/physical): 512/512 bytes
Disk identifier (GUID): BBF00249-692F-416D-AEE5-FFCE604D1B99
Partition table holds up to 128 entries
Main partition table begins at sector 2 and ends at sector 33
First usable sector is 34, last usable sector is 500118158
Partitions will be aligned on 2048-sector boundaries
Total free space is 441397869 sectors (210.5 GiB)

Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048        33556479   16.0 GiB    8300  super
   2        33556480        50333695   8.0 GiB     8300  data
   3        50333696        54527999   2.0 GiB     8300  cache
   4        54528000        56625151   1024.0 MiB  8300  metadata
   5        56625152        58722303   1024.0 MiB  8300  boot

## 注意，这里的 boot分区暂时用不上，如前面的蓝色文字描述的，boot相关的信息都放在了系统盘（loongnix）的boot分区中


## 第三步，获取Android硬盘的设备号
$ udevadm info -q path -n /dev/sda  ## 或者使用 -q all
/devices/pci0000:00/0000:00:08.2/ata3/host2/target2:0:0/2:0:0:0/block/sda
$ lspci -vv -s 0000:00:08.2
# 上述显示的设备信息 pci0000:00/0000:00:08.2 会在配置文件 ‘/boot/grub/grub.cfg’ 中使用

#或者采用命令获取上述信息
$ realpath /sys/block/sda
/sys/devices/pci0000:00/0000:00:08.2/ata3/host2/target2:0:0/2:0:0:0/block/sda

## 第四步

```

上述信息信息`pci0000:00/0000:00:08.2`记录下来要放到安卓内核启动命令行: androidboot.boot_devices=pci0000:00/0000:00:08.2。 安卓的init程序依赖这个参数去找到安卓对应的分区。

注意<span style="color:blue">**分区必须使用GPT分区而不是传统的MBR分区**</span>，建议使用gdisk软件。推荐的硬盘分区如下：

```bash
### TODO
$ sudo echo -e 'n\n\n\n+16G\n\nn\n\n\n+8G\n\nn\n\n\n+8G\n\nn\n\n\n+32M\n\nn\n\n\n+4G\n\nc\n1\nsuper\nc\n2\ndata\nc\n3\ncache\nc\n4\nmetadata\nc\n5\nboot\nwq\nY\n' | sudo gdisk /dev/sdb
# partion 1: super
# partion 2: userdata
# partion 3: cache
# partion 4: metadata
# partion 5: boot

```

具体分区大小可以改变，但不能小于安卓设定的相关分区image大小。



如果是一个硬盘，分区信息大概如下（龙芯采用的方式）

```bash
loongson@loongson-pc:~$ sudo gdisk
GPT fdisk (gdisk) version 1.0.3

Type device filename, or press <Enter> to exit: /dev/sda
Partition table scan:
  MBR: protective
  BSD: not present
  APM: not present
  GPT: present

Found valid GPT with protective MBR; using GPT.

Command (? for help): p
Disk /dev/sda: 500118192 sectors, 238.5 GiB
Model: YMTC SC001-256GB
Sector size (logical/physical): 512/512 bytes
Disk identifier (GUID): D647FC08-8976-4385-A183-BB1F67ACB5DA
Partition table holds up to 128 entries
Main partition table begins at sector 2 and ends at sector 33
First usable sector is 34, last usable sector is 500118158
Partitions will be aligned on 2-sector boundaries
Total free space is 146565775 sectors (69.9 GiB)

Number  Start (sector)    End (sector)  Size       Code  Name
   1              34          616447   301.0 MiB   0700  
   2          616448         1230847   300.0 MiB   8300  
   3         1230848       282249215   134.0 GiB   8300  
   4       282249216       315803647   16.0 GiB    8200  
   5       315803648       336775167   10.0 GiB    8300  super
   6       336775168       345163775   4.0 GiB     8300  data
   7       345163776       349358079   2.0 GiB     8300  cache
   8       349358080       351455231   1024.0 MiB  8300  metadata
   9       351455232       353552383   1024.0 MiB  8300  boot
```

单硬盘模式的其他内容不再赘述。



### 1.2 GPU硬件信息确认

3A5000测试机，Radeon 520OEM显卡,串口用于连接3A5000测试机以及工作机（串口软件minicom或者picocom），HDMI线连接显卡和显示器（VGA线暂时不支持）

```
$ lspci |grep "VGA compatible controller" | awk '{print $1}' |xargs lspci -v -s

06:00.0 VGA compatible controller: Advanced Micro Devices, Inc. [AMD/ATI] Oland [Radeon HD 8570 / R5 430 OEM / R7 240/340 / Radeon 520 OEM] (rev 87) (prog-if 00 [VGA controller])
        Subsystem: Bitland(ShenZhen) Information Technology Co., Ltd. Radeon 520 OEM
        Flags: bus master, fast devsel, latency 0, IRQ 48, NUMA node 0
        Memory at e0030000000 (64-bit, prefetchable) [size=256M]
        Memory at e0041000000 (64-bit, non-prefetchable) [size=256K]
        I/O ports at 4000 [size=256]
        Expansion ROM at e0041040000 [disabled] [size=128K]
        Capabilities: <access denied>
        Kernel driver in use: radeon
        Kernel modules: radeon, amdgpu
        
```




# 2. 硬盘分区配置

需要注意的是，fstab需要与硬盘分区信息一致。我们设置了两个fstab文件，分别是

文件`fstab.loongson_3a5000.ramdisk`用于ramdisk.

```bash
$ cat loongson_3a5000/fstab.loongson_3a5000.ramdisk 
#<src>              <mnt_point>         <type>    	<mnt_flags and options>               	<fs_mgr_flags>
system    			/system             ext4      	ro,barrier=1                          	wait,logical,first_stage_mount
vendor    			/vendor             ext4      	ro,barrier=1                          	wait,logical,first_stage_mount


$ cat loongson_3a5000/fstab.loongson_3a5000
#<src>              <mnt_point>         <type>    	<mnt_flags and options>                               	<fs_mgr_flags>
system    			/system             ext4      	ro,barrier=1                                          	wait,logical,first_stage_mount
vendor    			/vendor             ext4      	ro,barrier=1                                          	wait,logical,first_stage_mount

/dev/block/sda2 	/data       		ext4      	noatime,nosuid,nodev,nomblk_io_submit,errors=panic   	wait,check,quota,reservedsize=128M,latemount
/dev/block/sda3 	/cache      		ext4      	noatime,nosuid,nodev,nomblk_io_submit,errors=panic  	wait,check,quota,reservedsize=128M,latemount
/dev/block/sda4 	/metadata   		ext4    	noatime,nosuid,nodev    							wait,formattable,latemount

```



# 3.烧录

编译完成后可以使用测试机中的loongnix系统下载镜像并烧录。
这里提供一下烧录脚本，用于从源码所在的服务器或者工作机上把镜像下载到本地并烧录到对应分区

```bash
#!/bin/bash
server=172.17.103.55 
password=****
username=dongzhe
remote_dir=/home/dongzhe/loongson/aosp.la/out/target/product/generic_loongarch64
image_files=(
        "super.img"
        "userdata.img"
        "ramdisk.img"
        "cache.img"
        )
for file in "${image_files[@]}"; do
        sshpass -p "${password}" scp  "${username}@${server}:${remote_dir}/${file}" ./
        if [ $? -eq 0 ];then
                echo "copy successed: ${file}"
        else
                echo "copy failed: ${file}"
        fi
done
```



### 3.1 烧录

```bash
sudo dd if=super.img     of=/dev/sda1 bs=32M
sudo dd if=userdata.img  of=/dev/sda2 bs=32M
sudo dd if=cache.img     of=/dev/sda3 bs=32M

sudo mkfs.ext4 /dev/sda4
```



### 3.2 ramdisk

ramdisk文件一旦确定，后续基本不变，所以，正常情况下，只需要更改一次即可。

将ramdisk.img 放置在 `/boot`目录下 （参考第4节，关于启动参数中描述的ramdisk）。



# 4.启动参数

启动3A5000 linux系统，编辑/boot/grub/grub.cfg文件，增加如下内容（目前采用的是Android12）：

```bash
menuentry 'Android12' {
  echo	'Loading Android ...'
	set root='hd0,gpt2'
	linux  /vmlinuz.efi console=ttyS0,115200 norandmaps earlycon enforcing=0 init=/init  rw rootfstype=cpio androidboot.hardware=loongson_3a5000 androidboot.selinux=permissive loglevel=1 androidboot.boot_devices=pci0000:00/0000:00:08.2 loglevel=8 printk.devkmsg=on androidboot.verifiedbootstate=orange
  echo  'Loading initrd...'
	initrd	/ramdisk.img
}

```
注意：boot_devices需与sda所在的pci地址保持一致
```bash
## 参考1.1 中描述的步骤、内容

androidboot.boot_devices=pci0000:00/0000:00:08.2
```
编辑后，并使用sudo update-grub，启动时可以在grub界面选择进入android12。

特别注意上述参数： `androidboot.hardware=loongson_3a5000`



## 注意!!!： 3A5000安卓内核

目前模拟器使用的安卓内核理论上可以直接用于3A5000真机，但是实际有两个问题需要处理：

2. 真机的radeon显卡驱动需要加载一些固件，由于android.img没有内置这些文件，需要处理。一种办法是内置到内核，配置内核(Device Drivers/Generic Driver Options/Firmware Loader/Firmware blobs root directory和firmware loading facility),参考配置如下（根据显卡型号不同内置文件也不同）。另一种办法是将linux /lib/firmware目录下相关文件加入ramdisk.img. 

```bash
CONFIG_EXTRA_FIRMWARE="radeon/oland_pfp.bin radeon/oland_me.bin radeon/oland_smc.bin radeon/oland_ce.bin radeon/oland_rlc.bin radeon/oland_mc.bin radeon/oland_k_smc.bin"
CONFIG_EXTRA_FIRMWARE_DIR="/lib/firmware"
```



# 5. 注意事项

1. 安装应用：大部分带有so文件的APK安装文件不能安装在本系统中（so文件往往会带有架构相关的代码）

2. 如果采用触摸屏，需要在编译kernel的时候enable部分选项。

   

3. 提交的AOSP中，采用了手势导航方式:

   ```diff
   diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
   index db43b5b3..d120d4a6 100644
   --- a/core/res/res/values/config.xml
   +++ b/core/res/res/values/config.xml
   @@ -3434,7 +3434,7 @@
             0: 3 button mode (back, home, overview buttons)
             1: 2 button mode (back, home buttons + swipe up for overview)
             2: gestures only for back, home and overview -->
   -    <integer name="config_navBarInteractionMode">0</integer>
   +    <integer name="config_navBarInteractionMode">2</integer>
   ```

4. 缺省的显示是中文方式

   ```bash
   # common/common_la.mk
   PRODUCT_LOCALES := zh_CN
   ```

5. 系统时会有Keystore错误，这个错误不影响后续使用，只是在启动时会存在，原因是没有生成对应的密码Provider（缺省的是TEE提供）





# 6. ART注意事项

当前版本的ART虚拟机还是以解释方式运行的。需要进一步移植为AOT、JIT方式。

在移植JIT、AOT方式时需要注意如下事项：

1. 步骤 - 正常情况下是优先移植JIT、然后再AOT。

2. 测试 - 缺省情况下，ART提供了5中测试模式

   ```bash
     ## 以下五种模式是缺省的，不指定模式的时候测试的五种缺省模式
      --interpreter
      --jit   【测试的时候还可以强制使用： --jit-on-first-use 选项，保证必须采用JIT进行测试】
      --optimizing
      --speed-profile
      --interp-ac
   ```

3. 因为ART本身不支持纯Interpreter执行（缺省情况下，AOT是一定支持的），因此，当前代码中做了一些HACK，当JIT Enable后，必须将其修订回来

   ```bash
   ## ART git
   checkin: 874fab84f6954cad49d549176ba75966d145cda7
   checkin: cbc74adb95652af85a05ef7989afcdc54ed470a5
   
   ## device/loongson/loongsonboard/
   dalvik.vm.usejit = false ## 需要修改为true
   WITH_DEXPREOPT := false ## 需要修改为true
   
   ## build/make
   checkin: 64e29b4aa7
   
   ## frameworks/base
   checkin: 7da02639
   ```

   
